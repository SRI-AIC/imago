import numpy as np
from sklearn.cluster import KMeans
from pathlib import Path
from PIL import ImageDraw, ImageFont

from imago.perturb.analysis import scan, endpt_vs_starts

"""
Cluster level analyses of vectors.
"""

def kmeans_over_scan_res(results_rootdir, model,
                         D, render_fn,
                         DEBUG=False,
                         results_dir="results", z_dim=256,
                         N_CLABELS=10                         ):
    """ Given a set of results generated by scan() in pvae.perturb.analysis,
    performs a cluster level analysis of the directions."""
    results_dir.mkdir(parents=True, exist_ok=True)

    start_Zs = []
    Vs = []
    # Scan through all vector results and get starting scenes, vectors
    for npz_fpath in results_rootdir.rglob("scene_*/vecs.npz"):
        V = np.load(npz_fpath)
        start_Zs.append(V['arr_0'])
        Vs.append(np.vstack([V["arr_{}".format(i)] for i in range(1, len(V))]))
    if DEBUG:
        start_Zs = start_Zs[0:10]
    start_Zs = np.stack(start_Zs)
    Vs = np.stack(Vs)
    X = Vs.reshape(-1, z_dim)
    # Now use clustering to see
    kmeans = KMeans(n_clusters=N_CLABELS, random_state=1337).fit(X)
    clabels = kmeans.predict(X)

    for clabel in range(N_CLABELS):
        matched = np.where(clabels == clabel)[0]
        print("#{}:\t{}".format(clabel, len(matched)))

    # Check divergence within each cluster
    def get_cluster(tgt_label):
        idxes = np.where(clabels == tgt_label)
        cluster = X[idxes]
        return cluster


    for cidx in range(N_CLABELS):
        C = get_cluster(cidx)
        if C is not None and len(C) > 0:
            print(C, np.std(C, axis=0))
            c_mu = np.mean(C, axis=0)
            endpt_vs_starts(c_mu, start_Zs, D, model,
                            render_fn, Path(results_dir, "Cluster_{:02d}".format(cidx)))